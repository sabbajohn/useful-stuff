#!/bin/bash

# Detecta o sistema operacional
OS="$(uname -s)"
case "${OS}" in
    Linux*)     MACHINE=Linux;;
    Darwin*)    MACHINE=macOS;;
    *)          MACHINE="UNKNOWN:${OS}"
esac

# Verifica se os comandos essenciais est√£o instalados
for cmd in gum; do
    if ! command -v $cmd &>/dev/null; then
        echo "Erro: '$cmd' n√£o est√° instalado."
        if [[ "$MACHINE" == "macOS" ]]; then
            echo "Para instalar no macOS: brew install gum"
        else
            echo "Para instalar no Linux: https://github.com/charmbracelet/gum#installation"
        fi
        exit 1
    fi
done

# Verifica disponibilidade de ferramentas de download
HAS_CURL=false
HAS_WGET=false
HAS_ARIA2=false
HAS_YOUTUBE_DL=false
HAS_YT_DLP=false

if command -v curl &>/dev/null; then
    HAS_CURL=true
fi

if command -v wget &>/dev/null; then
    HAS_WGET=true
fi

if command -v aria2c &>/dev/null; then
    HAS_ARIA2=true
fi

if command -v youtube-dl &>/dev/null; then
    HAS_YOUTUBE_DL=true
fi

if command -v yt-dlp &>/dev/null; then
    HAS_YT_DLP=true
fi

# Verifica se pelo menos uma ferramenta de download est√° dispon√≠vel
if [[ "$HAS_CURL" == false && "$HAS_WGET" == false && "$HAS_ARIA2" == false ]]; then
    echo "Erro: Nenhuma ferramenta de download dispon√≠vel."
    echo "Instale pelo menos uma: curl, wget ou aria2"
    if [[ "$MACHINE" == "macOS" ]]; then
        echo "  brew install curl wget aria2"
    else
        echo "  sudo apt install curl wget aria2  # Ubuntu/Debian"
        echo "  sudo yum install curl wget aria2  # RHEL/CentOS"
    fi
    exit 1
fi

# Arquivo de configura√ß√£o
CONFIG_FILE="$HOME/.download_manager_config"
DOWNLOADS_DIR="$HOME/Downloads"

# Fun√ß√£o para verificar se URL √© v√°lida
validate_url() {
    local url="$1"
    if [[ "$url" =~ ^https?:// ]]; then
        return 0
    else
        return 1
    fi
}

# Fun√ß√£o para obter tamanho do arquivo
get_file_size() {
    local url="$1"
    
    if [[ "$HAS_CURL" == true ]]; then
        size=$(curl -sI "$url" | grep -i content-length | awk '{print $2}' | tr -d '\r')
        if [[ -n "$size" ]]; then
            echo "$size"
            return 0
        fi
    fi
    
    if [[ "$HAS_WGET" == true ]]; then
        size=$(wget --spider --server-response "$url" 2>&1 | grep -i content-length | awk '{print $2}' | tr -d '\r')
        if [[ -n "$size" ]]; then
            echo "$size"
            return 0
        fi
    fi
    
    echo "Desconhecido"
}

# Fun√ß√£o para formatar tamanho em bytes
format_size() {
    local size="$1"
    if [[ "$size" == "Desconhecido" ]]; then
        echo "$size"
        return
    fi
    
    if (( size < 1024 )); then
        echo "${size} B"
    elif (( size < 1048576 )); then
        echo "$(( size / 1024 )) KB"
    elif (( size < 1073741824 )); then
        echo "$(( size / 1048576 )) MB"
    else
        echo "$(( size / 1073741824 )) GB"
    fi
}

# Fun√ß√£o para download simples
simple_download() {
    echo "üì• Download Simples"
    echo "=================="
    
    url=$(gum input --placeholder "Digite a URL para download")
    [[ -z "$url" ]] && return 0
    
    if ! validate_url "$url"; then
        echo "‚ùå URL inv√°lida. Use formato: http:// ou https://"
        return 1
    fi
    
    # Pergunta sobre diret√≥rio de destino
    use_custom_dir=$(gum confirm "Usar diret√≥rio personalizado?" && echo "yes" || echo "no")
    
    dest_dir="$DOWNLOADS_DIR"
    if [[ "$use_custom_dir" == "yes" ]]; then
        dest_dir=$(gum input --placeholder "Caminho do diret√≥rio de destino" --value "$DOWNLOADS_DIR")
        mkdir -p "$dest_dir"
    fi
    
    # Pergunta sobre nome do arquivo
    filename=$(basename "$url" | cut -d'?' -f1)
    custom_name=$(gum input --placeholder "Nome do arquivo (deixe vazio para usar padr√£o)" --value "$filename")
    if [[ -n "$custom_name" ]]; then
        filename="$custom_name"
    fi
    
    # Mostra informa√ß√µes do arquivo
    echo "üîç Analisando arquivo..."
    file_size=$(get_file_size "$url")
    formatted_size=$(format_size "$file_size")
    
    echo "üìã Informa√ß√µes do download:"
    echo "   URL: $url"
    echo "   Destino: $dest_dir/$filename"
    echo "   Tamanho: $formatted_size"
    echo
    
    # Escolhe ferramenta de download
    tools=()
    if [[ "$HAS_ARIA2" == true ]]; then
        tools+=("aria2c (recomendado)")
    fi
    if [[ "$HAS_CURL" == true ]]; then
        tools+=("curl")
    fi
    if [[ "$HAS_WGET" == true ]]; then
        tools+=("wget")
    fi
    
    selected_tool=$(gum choose "${tools[@]}")
    tool=$(echo "$selected_tool" | awk '{print $1}')
    
    # Executa download
    case "$tool" in
    "aria2c")
        cmd="aria2c --dir=\"$dest_dir\" --out=\"$filename\" --continue=true --max-connection-per-server=4 \"$url\""
        ;;
    "curl")
        cmd="curl -L --progress-bar -o \"$dest_dir/$filename\" \"$url\""
        ;;
    "wget")
        cmd="wget --progress=bar --show-progress -O \"$dest_dir/$filename\" \"$url\""
        ;;
    esac
    
    echo "üöÄ Executando: $cmd"
    echo "=================="
    
    if gum confirm "Iniciar download?"; then
        eval "$cmd"
        if [[ $? -eq 0 ]]; then
            echo "‚úÖ Download conclu√≠do com sucesso!"
            echo "üìÅ Arquivo salvo em: $dest_dir/$filename"
        else
            echo "‚ùå Erro durante o download"
        fi
    fi
}

# Fun√ß√£o para download em lote
batch_download() {
    echo "üì¶ Download em Lote"
    echo "=================="
    
    method=$(gum choose "Inserir URLs manualmente" "Carregar de arquivo")
    
    urls=()
    case "$method" in
    "Inserir URLs manualmente")
        echo "Digite as URLs (uma por linha). Digite 'FIM' para terminar:"
        while true; do
            url=$(gum input --placeholder "URL ${#urls[@]}+1 (ou 'FIM' para terminar)")
            if [[ "$url" == "FIM" || "$url" == "fim" ]]; then
                break
            fi
            if validate_url "$url"; then
                urls+=("$url")
                echo "‚úÖ Adicionada: $url"
            else
                echo "‚ùå URL inv√°lida ignorada: $url"
            fi
        done
        ;;
    "Carregar de arquivo")
        urls_file=$(gum input --placeholder "Caminho do arquivo com URLs")
        if [[ -f "$urls_file" ]]; then
            while IFS= read -r url; do
                url=$(echo "$url" | xargs)  # Remove espa√ßos
                if [[ -n "$url" ]] && validate_url "$url"; then
                    urls+=("$url")
                fi
            done < "$urls_file"
            echo "‚úÖ Carregadas ${#urls[@]} URLs v√°lidas do arquivo"
        else
            echo "‚ùå Arquivo n√£o encontrado: $urls_file"
            return 1
        fi
        ;;
    esac
    
    if [[ ${#urls[@]} -eq 0 ]]; then
        echo "‚ùå Nenhuma URL v√°lida encontrada"
        return 1
    fi
    
    # Configura√ß√µes do lote
    dest_dir=$(gum input --placeholder "Diret√≥rio de destino" --value "$DOWNLOADS_DIR")
    mkdir -p "$dest_dir"
    
    # Pergunta sobre downloads simult√¢neos
    if [[ "$HAS_ARIA2" == true ]]; then
        concurrent=$(gum input --placeholder "Downloads simult√¢neos (1-5)" --value "2")
        if ! [[ "$concurrent" =~ ^[1-5]$ ]]; then
            concurrent=2
        fi
    else
        concurrent=1
    fi
    
    echo "üìã Configura√ß√£o do lote:"
    echo "   URLs: ${#urls[@]}"
    echo "   Destino: $dest_dir"
    echo "   Simult√¢neos: $concurrent"
    echo
    
    if ! gum confirm "Iniciar downloads em lote?"; then
        return 0
    fi
    
    # Executa downloads
    if [[ "$HAS_ARIA2" == true ]]; then
        # Cria arquivo tempor√°rio com URLs
        temp_file="/tmp/download_urls_$$"
        printf '%s\n' "${urls[@]}" > "$temp_file"
        
        cmd="aria2c --dir=\"$dest_dir\" --continue=true --max-concurrent-downloads=$concurrent --max-connection-per-server=4 --input-file=\"$temp_file\""
        echo "üöÄ Executando: $cmd"
        eval "$cmd"
        rm -f "$temp_file"
    else
        # Download sequencial com curl/wget
        for i in "${!urls[@]}"; do
            url="${urls[$i]}"
            filename=$(basename "$url" | cut -d'?' -f1)
            echo "üì• Baixando $((i+1))/${#urls[@]}: $filename"
            
            if [[ "$HAS_CURL" == true ]]; then
                curl -L --progress-bar -o "$dest_dir/$filename" "$url"
            elif [[ "$HAS_WGET" == true ]]; then
                wget --progress=bar -O "$dest_dir/$filename" "$url"
            fi
        done
    fi
    
    echo "‚úÖ Downloads em lote conclu√≠dos!"
}

# Fun√ß√£o para download de v√≠deos
video_download() {
    if [[ "$HAS_YT_DLP" == false && "$HAS_YOUTUBE_DL" == false ]]; then
        echo "‚ùå yt-dlp ou youtube-dl n√£o est√£o instalados"
        echo "Para instalar:"
        if [[ "$MACHINE" == "macOS" ]]; then
            echo "  brew install yt-dlp"
        else
            echo "  pip install yt-dlp"
            echo "  # ou"
            echo "  sudo apt install yt-dlp  # Ubuntu 22.04+"
        fi
        return 1
    fi
    
    echo "üé• Download de V√≠deos"
    echo "===================="
    
    url=$(gum input --placeholder "URL do v√≠deo (YouTube, Vimeo, etc.)")
    [[ -z "$url" ]] && return 0
    
    # Escolhe ferramenta
    video_tool=""
    if [[ "$HAS_YT_DLP" == true ]]; then
        video_tool="yt-dlp"
    elif [[ "$HAS_YOUTUBE_DL" == true ]]; then
        video_tool="youtube-dl"
    fi
    
    # Pergunta sobre qualidade
    quality=$(gum choose "Melhor qualidade" "720p" "480p" "√Åudio apenas (MP3)")
    
    dest_dir=$(gum input --placeholder "Diret√≥rio de destino" --value "$DOWNLOADS_DIR")
    mkdir -p "$dest_dir"
    
    # Monta comando baseado na qualidade
    case "$quality" in
    "Melhor qualidade")
        cmd="$video_tool -o \"$dest_dir/%(title)s.%(ext)s\" \"$url\""
        ;;
    "720p")
        cmd="$video_tool -f 'best[height<=720]' -o \"$dest_dir/%(title)s.%(ext)s\" \"$url\""
        ;;
    "480p")
        cmd="$video_tool -f 'best[height<=480]' -o \"$dest_dir/%(title)s.%(ext)s\" \"$url\""
        ;;
    "√Åudio apenas (MP3)")
        cmd="$video_tool -x --audio-format mp3 -o \"$dest_dir/%(title)s.%(ext)s\" \"$url\""
        ;;
    esac
    
    echo "üöÄ Executando: $cmd"
    echo "=================="
    
    if gum confirm "Iniciar download?"; then
        eval "$cmd"
        if [[ $? -eq 0 ]]; then
            echo "‚úÖ Download conclu√≠do!"
        else
            echo "‚ùå Erro durante o download"
        fi
    fi
}

# Fun√ß√£o para retomar downloads
resume_download() {
    echo "üîÑ Retomar Downloads"
    echo "==================="
    
    if [[ "$HAS_ARIA2" == false ]]; then
        echo "‚ùå aria2c n√£o est√° dispon√≠vel"
        echo "A retomada de downloads requer aria2c"
        if [[ "$MACHINE" == "macOS" ]]; then
            echo "Para instalar: brew install aria2"
        else
            echo "Para instalar: sudo apt install aria2"
        fi
        return 1
    fi
    
    # Procura por arquivos .aria2 (downloads incompletos)
    incomplete_files=()
    if [[ -d "$DOWNLOADS_DIR" ]]; then
        while IFS= read -r -d '' file; do
            incomplete_files+=("$file")
        done < <(find "$DOWNLOADS_DIR" -name "*.aria2" -print0)
    fi
    
    if [[ ${#incomplete_files[@]} -eq 0 ]]; then
        echo "‚úÖ Nenhum download incompleto encontrado"
        return 0
    fi
    
    echo "üìã Downloads incompletos encontrados:"
    for file in "${incomplete_files[@]}"; do
        original_file="${file%.aria2}"
        echo "   üìÅ $(basename "$original_file")"
    done
    echo
    
    if gum confirm "Retomar todos os downloads incompletos?"; then
        for file in "${incomplete_files[@]}"; do
            original_file="${file%.aria2}"
            dir=$(dirname "$original_file")
            filename=$(basename "$original_file")
            
            echo "üîÑ Retomando: $filename"
            aria2c --dir="$dir" --out="$filename" --continue=true --max-connection-per-server=4
        done
        echo "‚úÖ Tentativa de retomada conclu√≠da!"
    fi
}

# Fun√ß√£o para gerenciar downloads
manage_downloads() {
    echo "üìä Gerenciar Downloads"
    echo "====================="
    
    action=$(gum choose "Listar arquivos baixados" "Limpar downloads incompletos" "Configurar diret√≥rio padr√£o" "Verificar espa√ßo em disco")
    
    case "$action" in
    "Listar arquivos baixados")
        if [[ -d "$DOWNLOADS_DIR" ]]; then
            echo "üìÅ Arquivos em $DOWNLOADS_DIR:"
            echo "=============================="
            ls -lh "$DOWNLOADS_DIR" | grep -v "^total" | while read -r line; do
                if [[ "$line" == d* ]]; then
                    echo "üìÅ $(echo "$line" | awk '{print $9}')"
                else
                    size=$(echo "$line" | awk '{print $5}')
                    name=$(echo "$line" | awk '{print $9}')
                    echo "üìÑ $name ($size)"
                fi
            done
        else
            echo "‚ùå Diret√≥rio de downloads n√£o encontrado: $DOWNLOADS_DIR"
        fi
        ;;
    "Limpar downloads incompletos")
        if [[ -d "$DOWNLOADS_DIR" ]]; then
            incomplete_count=$(find "$DOWNLOADS_DIR" -name "*.aria2" | wc -l)
            if [[ $incomplete_count -gt 0 ]]; then
                echo "üóëÔ∏è  Encontrados $incomplete_count arquivos incompletos"
                if gum confirm "Remover arquivos .aria2 (downloads incompletos)?"; then
                    find "$DOWNLOADS_DIR" -name "*.aria2" -delete
                    echo "‚úÖ Arquivos incompletos removidos"
                fi
            else
                echo "‚úÖ Nenhum arquivo incompleto encontrado"
            fi
        fi
        ;;
    "Configurar diret√≥rio padr√£o")
        new_dir=$(gum input --placeholder "Novo diret√≥rio padr√£o" --value "$DOWNLOADS_DIR")
        if [[ -n "$new_dir" ]]; then
            mkdir -p "$new_dir"
            echo "DOWNLOADS_DIR=\"$new_dir\"" > "$CONFIG_FILE"
            DOWNLOADS_DIR="$new_dir"
            echo "‚úÖ Diret√≥rio padr√£o alterado para: $new_dir"
        fi
        ;;
    "Verificar espa√ßo em disco")
        if [[ "$MACHINE" == "macOS" ]]; then
            df -h "$DOWNLOADS_DIR"
        else
            df -h "$DOWNLOADS_DIR"
        fi
        ;;
    esac
}

# Fun√ß√£o principal de resumo
download_summary() {
    clear
    echo "üìã RESUMO DO DOWNLOAD MANAGER"
    echo "============================="
    
    # Mostra informa√ß√µes do sistema
    echo "üíª Sistema: $MACHINE"
    echo "üìÅ Diret√≥rio padr√£o: $DOWNLOADS_DIR"
    echo
    
    echo "üîß Ferramentas dispon√≠veis:"
    if [[ "$HAS_CURL" == true ]]; then
        echo "   ‚úÖ curl"
    else
        echo "   ‚ùå curl"
    fi
    
    if [[ "$HAS_WGET" == true ]]; then
        echo "   ‚úÖ wget"
    else
        echo "   ‚ùå wget"
    fi
    
    if [[ "$HAS_ARIA2" == true ]]; then
        echo "   ‚úÖ aria2c (recomendado)"
    else
        echo "   ‚ùå aria2c"
    fi
    
    if [[ "$HAS_YT_DLP" == true ]]; then
        echo "   ‚úÖ yt-dlp"
    elif [[ "$HAS_YOUTUBE_DL" == true ]]; then
        echo "   ‚úÖ youtube-dl"
    else
        echo "   ‚ùå yt-dlp/youtube-dl"
    fi
    
    echo
    
    # Mostra estat√≠sticas do diret√≥rio
    if [[ -d "$DOWNLOADS_DIR" ]]; then
        file_count=$(find "$DOWNLOADS_DIR" -type f ! -name "*.aria2" | wc -l)
        incomplete_count=$(find "$DOWNLOADS_DIR" -name "*.aria2" | wc -l)
        
        echo "üìä Estat√≠sticas:"
        echo "   üìÑ Arquivos baixados: $file_count"
        if [[ $incomplete_count -gt 0 ]]; then
            echo "   ‚è≥ Downloads incompletos: $incomplete_count"
        fi
        
        # Mostra espa√ßo em disco
        echo "   üíæ Espa√ßo dispon√≠vel:"
        if [[ "$MACHINE" == "macOS" ]]; then
            df -h "$DOWNLOADS_DIR" | tail -1 | awk '{print "      " $4 " livres de " $2}'
        else
            df -h "$DOWNLOADS_DIR" | tail -1 | awk '{print "      " $4 " livres de " $2}'
        fi
    fi
    
    echo
    gum confirm "Deseja retornar ao menu?" || exit 0
}

# Carrega configura√ß√µes se existirem
if [[ -f "$CONFIG_FILE" ]]; then
    source "$CONFIG_FILE"
fi

# Loop principal
echo "üì• Download Manager - Sistema: $MACHINE"
echo "üìÅ Diret√≥rio: $DOWNLOADS_DIR"
echo

while true; do
    opcao=$(gum choose \
        "üìã Resumo completo" \
        "üì• Download simples" \
        "üì¶ Download em lote" \
        "üé• Download de v√≠deos" \
        "üîÑ Retomar downloads" \
        "üìä Gerenciar downloads" \
        "üö™ Sair")

    case "$opcao" in
    "üìã Resumo completo")
        download_summary
        ;;
    "üì• Download simples")
        simple_download
        gum confirm "Deseja retornar ao menu?" || exit 0
        ;;
    "üì¶ Download em lote")
        batch_download
        gum confirm "Deseja retornar ao menu?" || exit 0
        ;;
    "üé• Download de v√≠deos")
        video_download
        gum confirm "Deseja retornar ao menu?" || exit 0
        ;;
    "üîÑ Retomar downloads")
        resume_download
        gum confirm "Deseja retornar ao menu?" || exit 0
        ;;
    "üìä Gerenciar downloads")
        manage_downloads
        gum confirm "Deseja retornar ao menu?" || exit 0
        ;;
    "üö™ Sair")
        echo "üëã Obrigado por usar o Download Manager!"
        exit 0
        ;;
    esac
done
